---

---

<sy-gl></sy-gl>

<script>
  import * as THREE from "three";

  import gsap from "gsap";
  import { addResizeObserver } from "../utils/observers";
  import ScrollTrigger from "gsap/ScrollTrigger";

  gsap.registerPlugin(ScrollTrigger);

  const scene = new THREE.Scene();
  const frustumSize = 5;
  let aspect = window.innerWidth / window.innerHeight;
  const camera = new THREE.OrthographicCamera(
    (-frustumSize * aspect) / 2,
    (frustumSize * aspect) / 2,
    frustumSize / 2,
    -frustumSize / 2,
    0,
    10.6,
  );

  camera.position.set(0, 0, 10);
  camera.lookAt(0, 0, 0);
  camera.updateProjectionMatrix();

  const renderer = new THREE.WebGLRenderer({
    antialias: true,
  });
  const canvas = renderer.domElement;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  renderer.setClearColor("#fff");
  renderer.setClearAlpha(0);

  // Performance optimization: simplify animations on mobile and for users who prefer reduced motion
  const prefersReducedMotion =
    window.matchMedia?.("(prefers-reduced-motion: reduce)").matches ?? false;
  const isMobile = window.innerWidth < 768;
  const isTablet = window.innerWidth >= 768 && window.innerWidth < 1024;
  
  // Always enable GL, but use simpler animations on mobile/tablet
  const SIMPLIFY_ANIMATIONS = isMobile || isTablet || prefersReducedMotion;

  const radius = 1;
  const detail = 2;
  const baseGeo = new THREE.IcosahedronGeometry(radius, detail);
  const posAttr = baseGeo.attributes.position;

  const globals = {
    uTime: { value: 0 },
    uVel: { value: 0 },
    uResolution: {
      value: new THREE.Vector2(window.innerWidth, window.innerHeight),
    },
  };

  const appleLiquidShader = {
    vertexShader: `
precision mediump float;
varying vec3 vNormal;
varying vec3 vPosition;
varying vec3 vWorldPosition;
varying vec3 vViewDirection;
varying vec2 vUv;

uniform float uTime;
uniform float uVel;
uniform float uRand;
uniform float uDisplacement;
uniform vec3 uDirection;

void main() {
  vec3 pos = position;
  pos += uDirection * uVel * 0.005 * uRand;
  pos += uDirection * uDisplacement;
  pos += uDirection * sin(uTime * 0.002 * uRand) * 0.015;
  vNormal = normalMatrix * normal;
  vPosition = pos;
  vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;

  vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
  vViewDirection = -mvPosition.xyz;

  // Generate UVs for extruded geometry
  vUv = uv;

  gl_Position = projectionMatrix * mvPosition;
}
    `,

    fragmentShader: `
precision mediump float;

uniform sampler2D uBackground;
uniform vec2 uResolution;
uniform float uTime;
uniform float uRefraction;
uniform float uBevelDepth;
uniform float uBevelWidth;
uniform bool uSpecular;
uniform float uRand;
uniform float uAlpha;
uniform float uActive;

varying vec3 vNormal;
varying vec3 vPosition;
varying vec3 vWorldPosition;
varying vec3 vViewDirection;
varying vec2 vUv;

float random(vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

// Edge detection based on normal angle (for triangular shape)
float triangleEdgeFactor(vec2 uv) {
  // Distance from center
  vec2 p = uv - 0.5;
  float centerDist = length(p);

  // Create smooth edge falloff
  float edgeDist = min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y));
  float bevelSize = uBevelWidth * 0.5;

  return smoothstep(0.0, bevelSize, edgeDist);
}

void main() {
  vec3 normal = normalize(vNormal);
  vec3 viewDir = normalize(vViewDirection);

  // Calculate screen UV for background sampling
  vec2 screenUV = gl_FragCoord.xy / uResolution;

  // Edge factor for beveling
  float edge = 1.0 - triangleEdgeFactor(vUv);

  // Refraction offset calculation
  float offsetAmt = (edge * uRefraction + pow(edge, 10.0) * uBevelDepth);

  // Use view direction and normal for refraction direction
  vec3 refractDir = refract(viewDir, normal, 0.9); // Glass-like IOR
  vec2 refractOffset = refractDir.xy * offsetAmt;

  // Center blend to reduce distortion in the middle
  vec2 p = vUv - 0.5;
  float centreBlend = smoothstep(0.15, 0.45, length(p));

  // Additional offset based on geometry orientation
  vec2 normalOffset = normalize(p) * offsetAmt * centreBlend;

  // Combine offsets
  vec2 offset = refractOffset + normalOffset * 0.5;

  // Calculate refracted UV
  vec2 refractedUV = screenUV + offset;

  // Clamp to screen bounds with smooth fallback
  float oob = max(
    max(-refractedUV.x, refractedUV.x - 1.0),
    max(-refractedUV.y, refractedUV.y - 1.0)
  );
  float blend = 1.0 - smoothstep(0.0, 0.01, oob);
  vec2 sampleUV = mix(screenUV, refractedUV, blend);

  // Sample background
  vec4 baseCol = texture2D(uBackground, screenUV);
  vec2 texel = 1.0 / vec2(textureSize(uBackground, 0));
  vec4 refrCol;

  if (baseCol.a < 0.01) {
    baseCol = vec4(0.9, 0.9, 0.9, 0.3);
  }

  // baseCol = mix(vec4(0.9, 0.9, 0.9, 0.3));

  // Simple blur for smoothness
  refrCol = texture2D(uBackground, sampleUV);
  // refrCol += texture2D(uBackground, sampleUV + vec2(texel.x, 0.0));
  // refrCol += texture2D(uBackground, sampleUV + vec2(-texel.x, 0.0));
  // refrCol += texture2D(uBackground, sampleUV + vec2(0.0, texel.y));
  // refrCol += texture2D(uBackground, sampleUV + vec2(0.0, -texel.y));
  // refrCol /= 5.0;

  // Fallback to base color if refraction fails
  if (refrCol.a < 0.01) {
    refrCol = baseCol;
  }

  // refrCol = mix(refrCol, vec4(1., 1., 0.0, 0.2) * refrCol.a, uActive);
  refrCol.rgb += vec3(0.25, 0.25, 0.15) * uActive;

  vec4 final = refrCol;

  // Specular highlights (animated)
  if (uSpecular) {
    vec2 lp1 = vec2(sin(uTime * 0.002 * uRand), cos(uTime * 0.003 * uRand)) * 0.6 + 0.5;
    vec2 lp2 = vec2(sin(uTime * -0.004 * uRand + 1.5), cos(uTime * 0.0025 * uRand - 0.5)) * 0.6 + 0.5;

    float highlight = 0.0;
    highlight += smoothstep(0.4, 0.0, distance(vUv, lp1)) * 0.15;
    highlight += smoothstep(0.5, 0.0, distance(vUv, lp2)) * 0.12;

    // Modulate by edge for realistic glass shine
    highlight *= (1.0 - edge * 0.5);
    final.rgb += highlight;
  }

  // Fresnel effect for glass edges
  float fresnel = pow(1.0 - abs(dot(viewDir, normal)), 3.0);
  final.rgb += fresnel * 0.1 * edge;

  // Edge darkening for depth
  final.rgb *= mix(1.0, 0.85, edge);

  // Alpha for transparency
  final.a = mix(0.7, 0.95, edge) * final.a * uAlpha;

  gl_FragColor = final;
}
    `,
  };

  // ----- Build triangular prism per face (exact match) -----
  const ballGroup = new THREE.Group();
  const panelsGroup = new THREE.Group();
  scene.add(ballGroup);
  ballGroup.add(panelsGroup);

  // Safety guard: keep the sphere visible even if a placeholder produces bad values.
  // (Prevents scale=0 / NaN / off-screen jumps that can make it "disappear forever".)
  const lastSafe = {
    x: 0,
    y: 0,
    scale: 1,
  };

  const faceCount = posAttr.count / 3;
  const faceData: {
    mesh: THREE.Mesh;
    normal: THREE.Vector3;
    center: THREE.Vector3;
    originalOffset: number;
  }[] = [];

  const vA = new THREE.Vector3();
  const vB = new THREE.Vector3();
  const vC = new THREE.Vector3();
  const normal = new THREE.Vector3();
  const center = new THREE.Vector3();

  const shapeOffset = 0.9;
  const thickness = 0.02;
  const bevelSize = 0.02;
  const bevelSegments = 2;

  const renderTarget = new THREE.WebGLRenderTarget(1, 1, {
    minFilter: THREE.LinearFilter,
    magFilter: THREE.LinearFilter,
    format: THREE.RGBAFormat,
    depthBuffer: false,
    stencilBuffer: false,
    generateMipmaps: false,
  });

  for (let fi = 0; fi < faceCount; fi++) {
    const i3 = fi * 3;

    vA.fromBufferAttribute(posAttr, i3 + 0);
    vB.fromBufferAttribute(posAttr, i3 + 1);
    vC.fromBufferAttribute(posAttr, i3 + 2);

    normal.copy(vC).sub(vB).cross(vA.clone().sub(vB)).normalize();

    center
      .copy(vA)
      .add(vB)
      .add(vC)
      .multiplyScalar(1 / 3);

    const shrink = (v: THREE.Vector3) => center.clone().lerp(v, shapeOffset);
    const sA = shrink(vA);
    const sB = shrink(vB);
    const sC = shrink(vC);

    const shape = new THREE.Shape();
    shape.moveTo(0, 0);

    const to2D = (v: THREE.Vector3) => {
      const u = vB.clone().sub(sA).normalize();
      const w = normal.clone();
      const vDir = new THREE.Vector3().crossVectors(w, u);
      const vec = v.clone().sub(sA);
      return new THREE.Vector2(vec.dot(u), vec.dot(vDir));
    };

    shape.moveTo(to2D(sA).x, to2D(sA).y);
    shape.lineTo(to2D(sB).x, to2D(sB).y);
    shape.lineTo(to2D(sC).x, to2D(sC).y);
    shape.lineTo(to2D(sA).x, to2D(sA).y);

    const extrudeSettings = {
      steps: 2,
      depth: thickness,
      bevelEnabled: false,
      bevelThickness: bevelSize,
      bevelSize: bevelSize,
      bevelSegments: bevelSegments,
    };

    const geom = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    const matrix = new THREE.Matrix4();
    const u = vB.clone().sub(sA).normalize();
    const w = normal.clone();
    const vDir = new THREE.Vector3().crossVectors(w, u);

    matrix.makeBasis(u, vDir, w);
    matrix.setPosition(sA);
    geom.applyMatrix4(matrix);

    geom.computeVertexNormals();

    const mat = new THREE.ShaderMaterial({
      vertexShader: appleLiquidShader.vertexShader,
      fragmentShader: appleLiquidShader.fragmentShader,
      uniforms: {
        ...globals,
        uRand: { value: Math.random() + 0.1 },
        uDirection: { value: new THREE.Vector3(0).copy(normal) },
        uDisplacement: { value: Math.random() * -1.7 - 0.1 },
        uActive: { value: 0 },
        uAlpha: { value: 0 },
        uBackground: { value: renderTarget.texture },
        uRefraction: { value: 0.001 + Math.random() * 0.001 },
        uBevelDepth: { value: 0.008 + Math.random() * 0.002 },
        uBevelWidth: { value: 1.0 + Math.random() * 0.2 },
        uFrost: { value: 0.0 },
        uSpecular: { value: true },
      },
      transparent: true,
    });

    const mesh = new THREE.Mesh(geom, mat);
    panelsGroup.add(mesh);

    faceData.push({
      mesh,
      normal: normal.clone(),
      center: center.clone(),
      originalOffset: 0,
    });
  }

  /// circle
  const baseColor = "#FE3B7F";
  const colors = ["#FF9A3C", "#FFD93C"];

  const seed = Math.random() * 10;
  const waves = colors.map((c, i) => {
    const e = i + 1;
    return {
      color: new THREE.Color(c),
      noiseFreq: [2 + e / (colors.length + 1), 3 + e / (colors.length + 1)],
      noiseSpeed: 11 + 0.3 * e,
      noiseFlow: 6.5 + 0.3 * e,
      noiseSeed: seed + 10 * e,
      noiseFloor: 0.1,
      noiseCeil: 0.63 + 0.07 * e,
    };
  });

  // ---- GLSL HELPERS ----
  const blend = `
  vec3 blendNormal(vec3 base, vec3 blend) {
    return blend;
  }

  vec3 blendNormal(vec3 base, vec3 blend, float opacity) {
    return (blendNormal(base, blend) * opacity + base * (1.0 - opacity));
  }
  `;

  const noise = `
  //	Simplex 3D Noise
  //	by Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise)
  //
  vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
  vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

  float snoise(vec3 v){
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

  // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    //  x0 = x0 - 0. + 0.0 * C
    vec3 x1 = x0 - i1 + 1.0 * C.xxx;
    vec3 x2 = x0 - i2 + 2.0 * C.xxx;
    vec3 x3 = x0 - 1. + 3.0 * C.xxx;

  // Permutations
    i = mod(i, 289.0 );
    vec4 p = permute( permute( permute(
               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  // Gradients
  // ( N*N points uniformly over a square, mapped onto an octahedron.)
    float n_ = 1.0/7.0; // N=7
    vec3  ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

  //Normalise gradients
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

  // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                  dot(p2,x2), dot(p3,x3) ) );
  }
  `;

  // ---- SHADERS ----
  const vertexShader = `
  precision highp float;
  ${noise}
  ${blend}

  #define WAVES ${waves.length}

  struct WaveLayer {
    vec3 color;
    vec2 noiseFreq;
    float noiseSpeed;
    float noiseFlow;
    float noiseSeed;
    float noiseFloor;
    float noiseCeil;
  };

  uniform float uTime;
  uniform float uNoiseSpeed;
  uniform float uVel;
  uniform vec2 uResolution;
  uniform vec2 uNoiseFreq;
  uniform vec3 uBaseColor;
  uniform WaveLayer uWaveLayers[WAVES];

  varying vec3 vColor;
  varying vec3 vNormal;
  varying vec3 vPosition;
  varying vec2 vUv;

  void main() {
    vUv = uv;
    vNormal = normalize(normalMatrix * normal);
    vPosition = position;
    
    float sp = uTime * uNoiseSpeed + uVel * 0.0007;
    vec3 pos = position;
    vec3 color = uBaseColor;
    
    // Use 3D position for noise instead of UV for spherical effect
    vec3 noiseCoord = pos * uNoiseFreq.x * 2.0;

    for (int i = 0; i < WAVES; i++) {
      WaveLayer layer = uWaveLayers[i];
      float noiseVal = smoothstep(
        layer.noiseFloor,
        layer.noiseCeil,
        snoise(vec3(
          noiseCoord.x * layer.noiseFreq.x + sp * layer.noiseFlow,
          noiseCoord.y * layer.noiseFreq.y,
          noiseCoord.z * layer.noiseFreq.y + sp * layer.noiseSpeed + layer.noiseSeed
        )) * 0.5 + 0.5
      );

      color = blendNormal(color, layer.color, pow(noiseVal, 4.0));
    }

    vColor = color;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
  `;

  const fragmentShader = `
  precision highp float;

  varying vec2 vUv;
  varying vec3 vColor;
  varying vec3 vNormal;
  varying vec3 vPosition;

  void main() {
    // Calculate lighting for 3D sphere effect
    vec3 normal = normalize(vNormal);
    
    // Simple directional light from top-right
    vec3 lightDir = normalize(vec3(0.5, 0.8, 0.3));
    float lightIntensity = max(dot(normal, lightDir), 0.3); // Minimum 0.3 for ambient
    
    // Add rim lighting for more depth
    vec3 viewDir = normalize(-vPosition);
    float rim = 1.0 - max(dot(viewDir, normal), 0.0);
    rim = pow(rim, 2.0) * 0.3;
    
    // Combine lighting with color
    vec3 finalColor = vColor * lightIntensity + rim;
    
    // Always fully opaque - never transparent
    gl_FragColor = vec4(finalColor, 1.0);
  }
  `;

  const uniforms = {
    ...globals,
    uBaseColor: { value: new THREE.Color(baseColor) },
    uNoiseFreq: {
      value: new THREE.Vector2(0.0001, 0.0001).divideScalar(
        window.devicePixelRatio,
      ),
    },
    uNoiseSpeed: { value: 0.000005 },
    uWaveLayers: { value: waves },
    uAlpha: { value: 1.0 },
  };

  const material = new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    uniforms,
    transparent: false, // Fully opaque - no transparency
    depthWrite: true, // Ensure proper depth rendering
    depthTest: true,
  });

  // Use sphere geometry instead of plane for 3D volumetric effect
  const geometry = new THREE.SphereGeometry(0.85, 64, 64);
  const circle = new THREE.Mesh(geometry, material);
  // Ensure circle is always visible and rendered properly, regardless of rotation
  circle.renderOrder = 1; // Render after panels
  circle.position.z = 0.01; // Slightly in front to ensure visibility
  ballGroup.add(circle);

  const mouse = new THREE.Vector2();
  const toggled = new Set<number>();

  // Only enable interactive features on desktop for performance
  if (!SIMPLIFY_ANIMATIONS) {
    document.addEventListener("pointermove", (event) => {
      event.preventDefault();

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    });

    window.addEventListener("pointerdown", () => {
      raycaster.setFromCamera(mouse, camera);

      const intersect = raycaster.intersectObjects(
        panelsGroup.children,
        false,
      )[0];

      if (intersect) {
        const hit = intersect.object;
        const idx = faceData.findIndex((f) => f.mesh === hit);
        if (idx >= 0) togglePanel(idx);
      }
    });
  }

  function togglePanel(idx: number) {
    const data = faceData[idx];
    const mesh = data.mesh;

    const isTogg = toggled.has(idx);
    if (isTogg) {
      toggled.delete(idx);
    } else {
      toggled.add(idx);
    }

    gsap.fromTo(
      (mesh.material as any).uniforms.uDisplacement,
      {
        value: isTogg ? 0.1 : 0,
      },
      {
        value: isTogg ? 0 : 0.1,
      },
    );

    gsap.fromTo(
      (mesh.material as any).uniforms.uActive,
      {
        value: isTogg ? 1 : 0,
      },
      {
        value: isTogg ? 0 : 1,
      },
    );
  }

  const raycaster = new THREE.Raycaster();

  window.scrollVelocity = 0;
  window.scrollDirection = 1;
  window.scrollCurrent = 0;
  window.scrollStickyOffsets = window.scrollStickyOffsets || [];

  let smoothVel = 0;
  let pixelToUnit = -frustumSize / window.innerHeight;
  let isPlaced = true;

  // Smooth interpolation for fluid motion (prevents jerky movements)
  let currentX = 0;
  let currentY = 0;

  function animate(t: number) {
    uniforms.uTime.value = t * 1000;
    
    // Force sphere to be fully opaque - never transparent
    uniforms.uAlpha.value = 1.0;

    const vel = isPlaced ? 0 : window.scrollVelocity;
    const abs = Math.abs(vel);
    const dir = window.scrollDirection || 1;

    // Simplified rotation: less intensive on mobile
    const rotBase = SIMPLIFY_ANIMATIONS ? 0.001 : 0.002;
    const rotSpeed = SIMPLIFY_ANIMATIONS ? 0.0005 : 0.001;
    panelsGroup.rotation.y += (rotBase + abs * rotSpeed) * dir;
    panelsGroup.rotation.x += (rotBase + abs * rotSpeed) * -dir;

    smoothVel += (abs - smoothVel) * 0.05;
    globals.uVel.value = smoothVel;
    const scrollY = window.scrollCurrent ?? window.scrollY ?? 0;
    camera.position.y = scrollY * pixelToUnit;

    // ---- Motion with scroll: sphere in right half of screen, centered vertically ----
    const freqMultiplier = SIMPLIFY_ANIMATIONS ? 0.5 : 1.0;
    // Movement depends on both scroll and time
    const tt = scrollY * 0.0006 * freqMultiplier + t * 0.0003 * freqMultiplier;

    // Screen is divided in half - sphere stays in right half
    const maxX = (frustumSize * aspect) / 2;
    const screenWidth = window.innerWidth || 1;
    const unitsPerScreenX = (frustumSize * aspect) / screenWidth;
    
    // Right half starts at center (0) and goes to maxX
    // Position sphere in the middle of right half (at 75% of screen width)
    const rightHalfCenter = maxX * 0.5; // Center of right half
    const offsetFromEdge = 25 * unitsPerScreenX; // Small offset from edge
    const baseX = rightHalfCenter - offsetFromEdge;

    const speed = Math.min(abs, 20);
    // Reduced amplitude for smoother movement
    const ampBase = SIMPLIFY_ANIMATIONS ? 0.2 : 0.3;
    const ampMultiplier = SIMPLIFY_ANIMATIONS ? 0.02 : 0.03;
    const amp = ampBase + ampMultiplier * speed;

    // Horizontal sway - movement in right half
    const swayX = SIMPLIFY_ANIMATIONS
      ? Math.sin(tt * 0.7) * (0.4 * amp)
      : Math.sin(tt * 0.8) * (0.5 * amp) + Math.sin(tt * 1.5 + 1.0) * (0.25 * amp);
    const targetX = baseX + swayX;

    // Vertical bobbing - centered vertically
    const bobY = SIMPLIFY_ANIMATIONS
      ? Math.sin(tt * 0.6) * (0.3 * amp)
      : Math.sin(tt * 0.7) * (0.4 * amp) + Math.cos(tt * 0.6 + 1.8) * (0.2 * amp);
    
    // Sphere follows camera exactly - no parallax, no lag
    let targetY = camera.position.y + bobY;
    
    // Prevent sphere from going into footer area
    const footerEl = document.querySelector("sy-footer");
    if (footerEl) {
      const footerRect = footerEl.getBoundingClientRect();
      const footerTop = footerRect.top + window.scrollY;
      const footerTopInUnits = -(footerTop - window.innerHeight / 2) * pixelToUnit;
      
      // Limit sphere Y position to stay above footer
      const sphereRadius = 0.85; // Sphere radius in world units
      const maxY = footerTopInUnits - sphereRadius - 0.5; // Keep sphere above footer with margin
      
      if (targetY > maxY) {
        targetY = maxY;
      }
    }

    // Smooth interpolation (lerp) - eliminates jerky movements
    const lerpFactor = SIMPLIFY_ANIMATIONS ? 0.1 : 0.12;
    currentX += (targetX - currentX) * lerpFactor;
    currentY += (targetY - currentY) * lerpFactor;

    ballGroup.position.x = currentX;
    ballGroup.position.y = currentY;

    // Rotation speed depends on scroll speed and direction
    const baseRotSpeed = SIMPLIFY_ANIMATIONS ? 0.002 : 0.003;
    const scrollRotSpeed = Math.min(abs * 0.0004, 0.015); // Speed increases with scroll speed
    const ballRotSpeed = baseRotSpeed + scrollRotSpeed;
    
    ballGroup.rotation.y += ballRotSpeed * dir;
    ballGroup.rotation.x += ballRotSpeed * dir * 0.7;
    ballGroup.rotation.z += ballRotSpeed * dir * -0.5;

    const s = ballGroup.scale.x;
    if (Number.isFinite(s) && s > 0.05) {
      lastSafe.scale = s;
    }
    ballGroup.scale.setScalar(Math.max(0.15, lastSafe.scale));

    panelsGroup.visible = false;
    renderer.setRenderTarget(renderTarget);
    renderer.render(scene, camera);
    renderer.setRenderTarget(null);
    panelsGroup.visible = true;
    renderer.render(scene, camera);
  }

  // Always enable animation, but use lower FPS on mobile for performance
  const targetFPS = SIMPLIFY_ANIMATIONS ? 30 : 45;
  gsap.ticker.fps(targetFPS);
  gsap.ticker.add(animate);

  // Pause animation when tab is hidden to save CPU/GPU
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      gsap.ticker.remove(animate);
    } else {
      gsap.ticker.add(animate);
    }
  });

  const alphas: unknown[] = [];
  const displaces: unknown[] = [];

  circle.scale.setScalar(0);

  function animateIn() {
    const ease = "elastic.out(1.3, 0.7)";

    faceData.forEach((f) => {
      const uniforms = (f.mesh.material as any).uniforms;

      displaces.push(uniforms.uDisplacement);
      alphas.push(uniforms.uAlpha);
    });

    gsap.to(displaces, {
      value: 0,
      duration: 0.7,
      ease,
    });

    gsap.to(alphas, {
      value: 1,
      duration: 0.5,
      delay: "random(0, 0.2)",
    });

    // Circle (gradient sphere) is always fully opaque - no animation needed
    // Fragment shader ignores uAlpha and always renders at full opacity
    uniforms.uAlpha.value = 1.0;

    displaces.splice(0, displaces.length);
    alphas.splice(0, displaces.length);

    const s = {
      scale: 0,
    };
    gsap.to(s, {
      duration: 0.7,
      ease,
      scale: 1,
      onUpdate() {
        circle.scale.setScalar(s.scale);
      },
    });
  }

  setTimeout(animateIn, 200);

  class SyGL extends HTMLElement {
    height = 0;
    width = 0;
    tl: ReturnType<typeof gsap.timeline> | null = null;

    connectedCallback() {
      // Always ensure the global WebGL canvas is attached to the current host.
      if (canvas && canvas.parentElement !== this) {
        this.appendChild(canvas);
      }

      const raw = Array.from(
        document.querySelectorAll<HTMLElement>("[data-gl-place]"),
      );
      // Ignore placeholders that have no size (they can zero-out the sphere scale)
      const placeholders = raw.filter((el) => {
        const bcr = el.getBoundingClientRect();
        return bcr.width > 0 && bcr.height > 0;
      });

      if (!placeholders.length) {
        return;
      }

      let lastGood = {
        x: ballGroup.position.x || 0,
        y: ballGroup.position.y || 0,
        scale: ballGroup.scale.x || 1,
        factor: 1,
        sticky: false,
      };

      const getPosData = (el: HTMLElement) => {
        if (!positions.has(el)) {
          const { top: _top, left, width, height } = el.getBoundingClientRect();
          const top = _top + window.scrollY;

          // If placeholder is not measurable, keep last known good position/scale
          if (width <= 0 || height <= 0 || this.width <= 0 || this.height <= 0) {
            return lastGood;
          }

          const centerX = left + width / 2;
          const centerY = top + height / 2;

          const pixelToUnitX = (frustumSize * aspect) / this.width;
          const pixelToUnitY = frustumSize / this.height;

          const factor = parseFloat(
            el.getAttribute("data-gl-place-factor") || "1",
          );

          const sticky = el.hasAttribute("data-gl-place-sticky");

          const data = {
            x: (centerX - this.width / 2) * pixelToUnitX,
            y: -(centerY - this.height / 2) * pixelToUnitY,
            scale: width * pixelToUnitX * 0.5,
            factor,
            sticky,
          };

          // Guard against NaN/Infinity and zero scale
          const ok =
            Number.isFinite(data.x) &&
            Number.isFinite(data.y) &&
            Number.isFinite(data.scale) &&
            data.scale > 0.001;

          if (ok) {
            positions.set(el, data);
            lastGood = data;
          } else {
            return lastGood;
          }
        }

        return positions.get(el) || lastGood;
      };

      let positions = new WeakMap();

      const tl = gsap.timeline({
        defaults: {
          ease: "none",
        },
        scrollTrigger: {
          trigger: this,
          scrub: true,
          invalidateOnRefresh: true,
          // markers: true,
          fastScrollEnd: true,
          onRefresh: () => {
            positions = new WeakMap();
            setFirst();
          },
          start: () => `${Math.round(window.innerHeight / 2)}px center`,
          end: () => {
            // Use last measurable placeholder for end calculation
            const lastEl = placeholders[placeholders.length - 1];
            const last = lastEl.getBoundingClientRect();
            return `+=${Math.round(last.top + window.scrollY)}px bottom`;
          },
        },
      });

      const setFirst = () => {
        const first = placeholders[0];
        const data = getPosData(first);
        ballGroup.position.x = data.x;
        ballGroup.position.y = data.y;
        ballGroup.scale.setScalar(data.scale);
      };

      tl.add(() => {
        setFirst();
      });

      placeholders.forEach((hldr, i) => {
        const prev = placeholders[i - 1];

        if (!prev) {
          return;
        }

        const duration = () => {
          const p = getPosData(prev);
          const h = getPosData(hldr);

          var b = p.y - h.y;
          var c = Math.round(Math.sqrt(b * b) * 10);

          return c * p.factor;
        };

        tl.to(ballGroup.position, {
          duration,
          x: () => getPosData(hldr).x,
          y: () => getPosData(hldr).y,
        });

        tl.to(
          ballGroup.scale,
          {
            duration,
            x: () => getPosData(hldr).scale,
            y: () => getPosData(hldr).scale,
            z: () => getPosData(hldr).scale,
            onUpdate() {
              const prg = this.progress();

              if (prg === 0 || prg === 1) {
                isPlaced = true;
              } else if (isPlaced) {
                isPlaced = false;
              }
            },
          },
          "<",
        );
      });

      this.tl = tl;

      const resizeObserver = new ResizeObserver(() => {
        tl.scrollTrigger?.refresh();
      });
      resizeObserver.observe(document.body);
    }

    constructor() {
      super();

      addResizeObserver(this);

      this.onResize();
    }

    onResize = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;

      this.width = width;
      this.height = height;

      pixelToUnit = -frustumSize / height;

      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(width, height);

      globals.uResolution.value.x = canvas.width;
      globals.uResolution.value.y = canvas.height;

      renderTarget.setSize(width, height);

      aspect = width / height;
      camera.left = (-frustumSize * aspect) / 2;
      camera.right = (frustumSize * aspect) / 2;
      camera.top = frustumSize / 2;
      camera.bottom = -frustumSize / 2;
      camera.updateProjectionMatrix();

      this.tl?.scrollTrigger?.refresh();
    };

    getTotalStickyOffset(scrollY: number): [number, number] {
      let cameraOffset = 0;
      let sceneOffset = 0;

      window.scrollStickyOffsets.forEach(([start, end, current]) => {
        if (scrollY < start) {
          return;
        } else if (scrollY >= start && scrollY <= end) {
          cameraOffset += current;
          sceneOffset -= current;
        } else {
          cameraOffset = current;
        }
      });

      return [cameraOffset, sceneOffset];
    }
  }

  customElements.define("sy-gl", SyGL);
</script>

<style>
  sy-gl {
    position: fixed;
    z-index: 1;
    pointer-events: none;
    top: 0;
    left: 0;
  }

  /* Visual divider removed - invisible */
</style>
